#!/usr/bin/env python3
# SPDX-FileCopyrightText: 2025 Blender Authors
#
# SPDX-License-Identifier: GPL-2.0-or-later

"""Self-bootstrapping script to run the OpenAPI-to-Pydantic classes code generator.

This script creates its own virtualenv, installs its dependencies, and then runs
the generator.
"""

from pathlib import Path
import sys
import time
import warnings

# Paths of the OpenAPI YAML files to convert to Python code.
# These are relative to Blender's top level source directory.
#
# The generated Python files will be written to the same path,
# just with the `.py` suffix.
YAML_PATHS = [
    "scripts/modules/_bpy_internal/assets/remote_library_index/blender_asset_library_openapi.yaml",
]

# These arguments are quite likely to be used for all code generated with this
# generator, also later when we use this approach in other areas.
COMMON_ARGS = [
    # Because of the Blender code standard:
    "--use-double-quotes",

    # Make it strict unless there's a good reason not to:
    "--strict-nullable",

    # Ignore unknown fields in the parsed JSON. This way, the code generated now
    # has a chance of being be compatible with future versions of the schema (at
    # least, when that future version just adds new stuff).
    "--allow-extra-fields",

    # Automatically target the currently-running version of Python:
    f"--target-python-version={sys.version_info.major}.{sys.version_info.minor}",

    # Use `list[T]` instead of `typing.List[T]`:
    "--use-standard-collections",

    # Because we use Pydantic v2:
    "--output-model-type", "pydantic_v2.BaseModel",

    # Work around https://github.com/koxudaxi/datamodel-code-generator/issues/1870#issuecomment-2775689249
    "--use-annotated",

    # Remove the "generated on" timestamp from the output, so that running the
    # generator is idempotent.
    "--disable-timestamp",
]


CUSTOM_FILE_HEADER = """
# SPDX-FileCopyrightText: {year!s} Blender Authors
#
# SPDX-License-Identifier: GPL-2.0-or-later
#
# Generated by datamodel-codegen:
#   source filename:  {source_path.name!s}
"""


def main() -> None:
    """Run the datamodel code generator."""

    print("Generating data model files:")
    root_path = _find_blender_root()

    # Hide warnings about unknown `format` specifiers in the OpenAPI spec
    # file. The only warning I (Sybren) have seen so far is that `format: url`
    # on a string got ignored, because it's unknown. That's fine by me, but I
    # still want to see in the spec that this is a URL.
    warnings.filterwarnings(
        'ignore', "format of 'url' not understood for 'string' - using default",
    )

    for yaml_relpath in YAML_PATHS:
        yaml_path = root_path / yaml_relpath
        py_path = yaml_path.with_suffix('.py')

        print(f"  {yaml_path.relative_to(root_path)} -> {py_path.name}")

        _generate_datamodel(
            in_path=yaml_path,
            in_type="openapi",
            out_path=py_path,
        )

    print("Done generating data model files!")


def _generate_datamodel(in_path: Path, in_type: str, out_path: Path) -> None:
    """Run datamodel-codegen."""

    # `type: ignore` to ignore warnings that this module cannot be imported. Python checkers
    # won't understand this is run from a self-managed virtualenv.
    from datamodel_code_generator.__main__ import main as codegen_main  # type: ignore
    from datamodel_code_generator.__main__ import Exit  # type: ignore

    header = CUSTOM_FILE_HEADER.strip().format(
        year=time.localtime().tm_year,
        source_path=in_path,
    )

    args = [
        *COMMON_ARGS,
        "--input", str(in_path),
        "--input-file-type", in_type,
        "--output", str(out_path),
        "--custom-file-header", header,
    ]

    status = codegen_main(args)

    match status:
        case Exit.OK:
            return
        case Exit.ERROR:
            raise SystemExit("code generation failed")
        case Exit.KeyboardInterrupt:
            raise KeyboardInterrupt()
        case _:
            raise SystemExit(f"unknown result from code generation: {status}")


def _find_blender_root() -> Path:
    """Find the source code root path.

    Basically we go up the directory structure until `source/blender` can be
    resolved. That seems like a decent indicator.
    """

    path = Path(__file__).parent

    # At a root path, the path's parent is the same as the path itself.
    while path.parent != path:
        if (path / "source/blender").exists():
            return path
        path = path.parent

    raise SystemExit("Could not find the root path of Blender's source code")


# --------- Below this point is the self-bootstrapping logic ---------


import hashlib
import importlib.util
import subprocess
import tempfile
import venv


# Packages to install in the virtualenv:
REQUIREMENTS = [
    "pydantic ~= 2.10",
    "datamodel-code-generator ~= 0.28.2",
]

# Name of a module to import, to test whether dependencies have been installed or not.
TEST_INSTALL_MODULE = "pydantic"

# Get a stable temp directory based on the script's path. This is used for
# the virtualenv, which shouldn't be created in Blender's source code.
SCRIPT_PATH = Path(__file__).resolve()
SCRIPT_HASH = hashlib.md5(str(SCRIPT_PATH).encode()).hexdigest()[:8]  # Short hash for uniqueness
VENV_DIR = Path(tempfile.gettempdir()) / f"venv_blender_generate_datamodels_{SCRIPT_HASH}"

# Python executable inside the virtual environment.
VENV_PYTHON = VENV_DIR / "Scripts/python.exe" if sys.platform == "win32" else VENV_DIR / "bin/python"


def _create_virtualenv() -> None:
    """Create the virtual environment if it does not exist."""
    if VENV_DIR.exists():
        return
    print(f"Creating virtual environment at {VENV_DIR}")
    venv.create(VENV_DIR, with_pip=True)


def _install_dependencies() -> None:
    """Install required dependencies into the virtual environment."""
    print("Installing dependencies")
    # Pip doesn't like to be used as Python library, invoking it via the CLI is the best option.
    _run_command(str(VENV_PYTHON), "-m", "pip", "install", "--upgrade", "pip")
    _run_command(str(VENV_PYTHON), "-m", "pip", "install", "--upgrade", *REQUIREMENTS)


def _is_dependency_installed(package: str) -> bool:
    """Try importing a package to check if it is installed."""
    return importlib.util.find_spec(package) is not None


def _is_running_in_virtualenv() -> bool:
    """Check if the script is running inside the virtual environment."""
    return sys.prefix != sys.base_prefix  # Virtualenv modifies `sys.prefix`


def _run_command(*cmd: str) -> None:
    """Run a shell command and handle errors."""
    try:
        subprocess.run(cmd, check=True, text=True)
    except subprocess.CalledProcessError as e:
        print(f"Error running command: {' '.join(cmd)}", file=sys.stderr)
        print(f"Exit code: {e.returncode}", file=sys.stderr)
        sys.exit(e.returncode)


if __name__ == "__main__":
    _create_virtualenv()

    if not _is_running_in_virtualenv():
        print(f"Re-executing inside virtual environment at {VENV_DIR}")
        subprocess.run([str(VENV_PYTHON), *sys.argv], check=True, text=True)
        sys.exit()

    if not _is_dependency_installed(TEST_INSTALL_MODULE):
        _install_dependencies()

    # The virtual environment is active, so run the main script logic.
    main()
